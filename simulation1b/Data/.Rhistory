mean2 = mean(data2)
sd2 = sd(data2)
# Creating results vector
results = c(sprintf("%.5g",mean1), sprintf("%.5g",sd1), sprintf("%.5g",mean2),
sprintf("%.5g",sd2), sprintf("%.5g",compute$statistic), sprintf("%.5g",compute$p.value),compute[[2]])
# Naming the results for clarity
names(results) = c(paste("mean", trialType1, sep=" "),
paste("sd", trialType1, sep=" "),
paste("mean", trialType2, sep=" "),
paste("sd", trialType2, sep=" "),
"t_value",
"p_value",
"DoF")
# Returning the results with labels indicating trial type
return(results)
}
difODif = function(condition,condition2, trialType1, trialType2) {
# Subsetting the dataframe based on the input parameters
data1 = dataFrame$lookingTime[dataFrame$condition == condition & dataFrame$trialType == trialType1]-dataFrame$lookingTime[dataFrame$condition == condition & dataFrame$trialType == trialType2]
data2 = dataFrame$lookingTime[dataFrame$condition == condition2 & dataFrame$trialType == trialType1]-dataFrame$lookingTime[dataFrame$condition == condition2 & dataFrame$trialType == trialType2]
# Performing the paired t-test
compute = t.test(data1, data2, paired = TRUE)
# Calculating means and standard deviations for each group
mean1 = mean(data1)
sd1 = sd(data1)
mean2 = mean(data2)
sd2 = sd(data2)
# Creating results vector
results = c(sprintf("%.5g",mean1), sprintf("%.5g",sd1), sprintf("%.5g",mean2),
sprintf("%.5g",sd2), sprintf("%.5g",compute$statistic), sprintf("%.5g",compute$p.value),compute[[2]])
# Naming the results for clarity
names(results) = c(paste("mean", condition, sep=" "),
paste("sd", condition, sep=" "),
paste("mean", condition2, sep=" "),
paste("sd", condition2, sep=" "),
"t_value",
"p_value",
"DoF")
# Returning the results with labels indicating trial type
return(results)
}
postTTest(D,"People with\nInanimate Features", "Contact", "No Contact")
####################
####################
# HELPER FUNCTIONS #
####################
####################
postTTest = function(dataFrame, condition, trialType1, trialType2) {
# Subsetting the dataframe based on the input parameters
data1 = dataFrame$lookingTime[dataFrame$condition == condition & dataFrame$trialType == trialType1]
data2 = dataFrame$lookingTime[dataFrame$condition == condition & dataFrame$trialType == trialType2]
# Performing the paired t-test
compute = t.test(data1, data2, paired = TRUE)
# Calculating means and standard deviations for each group
mean1 = mean(data1)
sd1 = sd(data1)
mean2 = mean(data2)
sd2 = sd(data2)
# Creating results vector
results = c(sprintf("%.5g",mean1), sprintf("%.5g",sd1), sprintf("%.5g",mean2),
sprintf("%.5g",sd2), sprintf("%.5g",compute$statistic), sprintf("%.5g",compute$p.value),compute[[2]])
# Naming the results for clarity
names(results) = c(paste("mean", trialType1, sep=" "),
paste("sd", trialType1, sep=" "),
paste("mean", trialType2, sep=" "),
paste("sd", trialType2, sep=" "),
"t_value",
"p_value",
"DoF")
# Returning the results with labels indicating trial type
return(results)
}
# Posthocs
postTTest(D, "Objects", "Contact", "No Contact")
# Posthocs
postTTest(D.4s, "Objects", "Contact", "No Contact")
# Posthocs
postTTest(D.4s, "Objects", "Contact", "No Contact")
postTTest(D.4s, "People", "Contact", "No Contact")
postTTest(D.4s, "People with\nInanimate Features", "Contact", "No Contact")
postTTest(D.4s, "Objects with\nAnimate Features", "Contact", "No Contact")
lme.fit = lme(lookingTime~(trialType+condition)^2,
random=~1|ID, data = D.4s)
anova.lme(lme.fit)
postTTest(D.4s, "Objects", "Contact", "No Contact")
postTTest(D.4s, "People", "Contact", "No Contact")
postTTest(D.4s, "People with\nInanimate Features", "Contact", "No Contact")
postTTest(D.4s, "Objects with\nAnimate Features", "Contact", "No Contact")
####################
####################
# HELPER FUNCTIONS #
####################
####################
postTTest = function(dataFrame,dv, col1, col1level, col2, col2level1, col2level2) {
# Subsetting the dataframe based on the input parameters
data1 = D[[dv]][dataFrame[[col1]] == col1level & dataFrame[[col2]] == col2level1]
data2 = D[[dv]][dataFrame[[col1]] == col1level & dataFrame[[col2]] == col2level2]
# Performing the paired t-test
compute = t.test(data1, data2, paired = TRUE)
# Calculating means and standard deviations for each group
mean1 = mean(data1)
sd1 = sd(data1)
mean2 = mean(data2)
sd2 = sd(data2)
# Creating results vector
results = c(sprintf("%.5g",mean1), sprintf("%.5g",sd1), sprintf("%.5g",mean2),
sprintf("%.5g",sd2), sprintf("%.5g",compute$statistic), sprintf("%.5g",compute$p.value),compute[[2]])
# Naming the results for clarity
names(results) = c(paste("mean", col2level1, sep=" "),
paste("sd", col2level1, sep=" "),
paste("mean", col2level2, sep=" "),
paste("sd", col2level2, sep=" "),
"t_value",
"p_value",
"DoF")
# Returning the results with labels indicating trial type
return(results)
}
# Example use: postTTest(D,"lookingTime","condition","Hand","side","Same Side","Different Side")
difODif = function(dataFrame,dv, col1,col1level1,col1level2,col2,col2level1,col2level2) {
# Subsetting the dataframe based on the input parameters
data1 = dataFrame[[dv]][dataFrame[[col1]] == col1level1 & dataFrame[[col2]] == col2level1]-dataFrame[[dv]][dataFrame[[col1]] == col1level1 & dataFrame[[col2]] == col2level2]
data2 = dataFrame[[dv]][dataFrame[[col1]] == col1level2 & dataFrame[[col2]] == col2level1]-dataFrame[[dv]][dataFrame[[col1]] == col1level2 & dataFrame[[col2]] == col2level2]
# Performing the paired t-test
compute = t.test(data1, data2, paired = TRUE)
# Calculating means and standard deviations for each group
mean1 = mean(data1)
sd1 = sd(data1)
mean2 = mean(data2)
sd2 = sd(data2)
# Creating results vector
results = c(sprintf("%.5g",mean1), sprintf("%.5g",sd1), sprintf("%.5g",mean2),
sprintf("%.5g",sd2), sprintf("%.5g",compute$statistic), sprintf("%.5g",compute$p.value),compute[[2]])
# Naming the results for clarity
names(results) = c(paste("mean", col1level1, sep=" "),
paste("sd", col1level1, sep=" "),
paste("mean", col1level2, sep=" "),
paste("sd", col1level2, sep=" "),
"t_value",
"p_value",
"DoF")
# Returning the results with labels indicating trial type
return(results)
}
# Example use: difODif(D,"lookingTime", "condition","Hand","Puppet","side","Same Side","Different Side")
simplePostTTest = function(dataFrame,dv, col1, col1level1, col1level2) {
# Subsetting the dataframe based on the input parameters
data1 = D[[dv]][dataFrame[[col1]] == col1level1]
data2 = D[[dv]][dataFrame[[col1]] == col1level2]
# Performing the paired t-test
compute = t.test(data1, data2, paired = TRUE)
# Calculating means and standard deviations for each group
mean1 = mean(data1)
sd1 = sd(data1)
mean2 = mean(data2)
sd2 = sd(data2)
# Creating results vector
results = c(sprintf("%.5g",mean1), sprintf("%.5g",sd1), sprintf("%.5g",mean2),
sprintf("%.5g",sd2), sprintf("%.5g",compute$statistic), sprintf("%.5g",compute$p.value),compute[[2]])
# Naming the results for clarity
names(results) = c(paste("mean", col1level1, sep=" "),
paste("sd", col1level1, sep=" "),
paste("mean", col1level2, sep=" "),
paste("sd", col1level2, sep=" "),
"t_value",
"p_value",
"DoF")
# Returning the results with labels indicating trial type
return(results)
}
D.100 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
D.90 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
D.80 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
D.70 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
D.60 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
D.50 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
D.100.e3 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
D.90.e3 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
D.80.e3 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
D.70.e3 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
D.60.e3 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
D.50.e3 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
fix(D)
D = rbind(D.100, D.90, D.80, D.70, D.60, D.50,
D.100.e3, D.90.e3, D.80.e3, D.70.e3, D.60.e3, D.50.e3)
fix(D)
D = rbind(D.100, D.90, D.80, D.70, D.60, D.50)
# get dimensionality of D
dim(D)
# create ID column
D$ID = rep(1:120, each = 160)
# side
D$side = rep(c("Hand", "Train"), each = 8, times = 1200)
D$side = as.factor(D$side)
# side 2
D$side_two = rep(c("Left", "Right"), each = 4, times = 2400)
D$side_two = as.factor(D$side_two)
# create frequency column
D$frequency = rep(c("100 percent", "90 percent", "80 percent", "70 percent", "60 percent", "50 percent"),
each = 3200)
D$frequency = as.factor(D$frequency)
# looking time
D$looking_time = D$V3
# remove columns
D = D[,-c(1:3)]
# check the order of the levels of the frequency variable
levels(D$frequency)
# reorder levels of the frequency variable
D$frequency <- factor(D$frequency, levels = c("100 percent",
"90 percent",
"80 percent",
"70 percent",
"60 percent",
"50 percent"))
#####################
### MAIN ANALYSIS ###
#####################
lme.fit = lme(looking_time~side,
random=~1|ID, data = D)
library(lme4)
install.packages("lme4", dependencies = TRUE)
library(lme4)
library(nlme)
#####################
lme.fit = lme(looking_time~side,
random=~1|ID, data = D)
anova.lme(lme.fit)
# Posthocs
simplePostTTest(D,"looking_time","side","Hand","Train")
fix(D)
## HAND CONDITION ##
D.hand.100 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
D.hand.90 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
D.hand.80 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
D.hand.70 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
D.hand.60 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
D.hand.50 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
# combine dataframes into a single 'D' data frame
D = rbind(D.hand.100, D.hand.90, D.hand.80, D.hand.70, D.hand.60, D.hand.50)
dim(D)
length(rep(1:360, each = 160))
19200/3
fix(D)
length(rep(1:20, each = 160))
360/6
dim(D)
# combine dataframes into a single 'D' data frame
D = rbind(D.hand.100, D.hand.90, D.hand.80, D.hand.70, D.hand.60, D.hand.50)
# create an ID column
D$ID = rep(1:20, each = 160)
dim(D)
19200/4
4800/16
length(rep(1:300, each = 160))
length(rep(1:20, each = 16))
16*10
length(rep(1:20, each = 16))
length(rep(1:20, each = 160))
fix(D)
19200/160
length(rep(1:120, each = 160))
length(rep(c("100 percent", "90 percent", "80 percent", "70 percent", "60 percent", "50 percent"),
each = 3200, times = 3))
19200/6
length(rep(c("100 percent", "90 percent", "80 percent", "70 percent", "60 percent", "50 percent"),
each = 3200, times = 1))
# combine dataframes into a single 'D' data frame
D = rbind(D.hand.100, D.hand.90, D.hand.80, D.hand.70, D.hand.60, D.hand.50)
# create an ID column
D$ID = rep(1:120, each = 160)
# side
D$side = rep(c("Same Side", "Different Side"), each = 8, times = 3600)
# combine dataframes into a single 'D' data frame
D = rbind(D.hand.100, D.hand.90, D.hand.80, D.hand.70, D.hand.60, D.hand.50)
# create an ID column
D$ID = rep(1:120, each = 160)
# side
D$side = rep(c("Same Side", "Different Side"), each = 8, times = 3600)
# combine dataframes into a single 'D' data frame
D = rbind(D.hand.100, D.hand.90, D.hand.80, D.hand.70, D.hand.60, D.hand.50)
# create an ID column
D$ID = rep(1:120, each = 160)
# side
D$side = rep(c("Same Side", "Different Side"), each = 8, times = 3600)
fix(D)
19200/16
length(rep(c("Same Side", "Different Side"), each = 8, times = 1200))
D = rbind(D.hand.100, D.hand.90, D.hand.80, D.hand.70, D.hand.60, D.hand.50)
# create an ID column
D$ID = rep(1:120, each = 160)
# side
D$side = rep(c("Same Side", "Different Side"), each = 8, times = 1200)
D$side = as.factor(D$side)
# create frequency column
D$frequency = rep(c("100 percent", "90 percent", "80 percent", "70 percent", "60 percent", "50 percent"),
each = 3200, times = 1)
D$frequency = as.factor(D$frequency)
# looking time
D$lookingTime = D$V3
# remove columns and get the names of the resulting columns
D = D[,-c(1:3)]
names(D)
# check the order of the levels of the frequency variable
levels(D$frequency)
# reorder levels of the frequency variable
D$frequency <- factor(D$frequency, levels = c("100 percent",
"90 percent",
"80 percent",
"70 percent",
"60 percent",
"50 percent"))
# reorder levels of test trial
levels(D$side)
D$side <- factor(D$side, levels = c("Same Side",
"Different Side"))
lme.fit = lme(lookingTime~(condition+side)^2,
random=~1|ID, data = D)
lme.fit = lme(lookingTime~side,
random=~1|ID, data = D)
anova.lme(lme.fit)
# post hoc
simplePostTTest(D,"lookingTime","side","Same Side","Different Side")
data.100.1500.exp1 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.90.1500.exp1 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.80.1500.exp1 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.70.1500.exp1 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.60.1500.exp1 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.50.1500.exp1 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.100.1500.exp2 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.90.1500.exp2 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.80.1500.exp2 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.70.1500.exp2 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.60.1500.exp2 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.50.1500.exp2 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.100.1500.exp3 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.90.1500.exp3 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.80.1500.exp3 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.70.1500.exp3 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.60.1500.exp3 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.50.1500.exp3 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.100.1500.exp5 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.90.1500.exp5 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.80.1500.exp5 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.70.1500.exp5 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.60.1500.exp5 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
data.50.1500.exp5 = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
D = rbind(data.100.1500.exp1, data.90.1500.exp1, data.80.1500.exp1, data.70.1500.exp1, data.60.1500.exp1, data.50.1500.exp1,
data.100.1500.exp2, data.90.1500.exp2, data.80.1500.exp2, data.70.1500.exp2, data.60.1500.exp2, data.50.1500.exp2,
data.100.1500.exp3, data.90.1500.exp3, data.80.1500.exp3, data.70.1500.exp3, data.60.1500.exp3, data.50.1500.exp3,
data.100.1500.exp5, data.90.1500.exp5, data.80.1500.exp5, data.70.1500.exp5, data.60.1500.exp5, data.50.1500.exp5)
# add new columns
D$ID = rep(c(1:480), each = 40)
D$test_event = rep(c("Hand-Generated", "Self-Propelled"), each = 2, times = 4800)
D$test_event = as.factor(D$test_event)
D$exp = rep(c("Experiment 1","Experiment 2", "Experiment 3", "Experiment 5"), each = 4800)
D$exp = as.factor(D$exp)
# create frequency column
D$frequency = rep(c("100 percent", "90 percent", "80 percent", "70 percent", "60 percent", "50 percent"),
each = 800, times = 4)
D$frequency = as.factor(D$frequency)
D$looking_time = D$V3
# remove unnecessary columns
D = D[,-c(1:3)]
# check the order of the levels of the frequency variable
levels(D$frequency)
# reorder levels of the frequency variable
D$frequency <- factor(D$frequency, levels = c("100 percent",
"90 percent",
"80 percent",
"70 percent",
"60 percent",
"50 percent"))
# Posthocs
postTTest(D,"looking_time","exp","Experiment 1","test_event","Hand-Generated","Self-Propelled")
postTTest(D,"looking_time","exp","Experiment 2","test_event","Hand-Generated","Self-Propelled")
postTTest(D,"looking_time","exp","Experiment 3","test_event","Hand-Generated","Self-Propelled")
postTTest(D,"looking_time","exp","Experiment 5","test_event","Hand-Generated","Self-Propelled")
lme.fit = lme(lookingTime~(exp+test_event)^2,
random=~1|ID, data = D)
lme.fit = lme(looking_time~(exp+test_event)^2,
random=~1|ID, data = D)
anova.lme(lme.fit)
# Posthocs
postTTest(D,"looking_time","exp","Experiment 1","test_event","Hand-Generated","Self-Propelled")
postTTest(D,"looking_time","exp","Experiment 2","test_event","Hand-Generated","Self-Propelled")
postTTest(D,"looking_time","exp","Experiment 3","test_event","Hand-Generated","Self-Propelled")
postTTest(D,"looking_time","exp","Experiment 3","test_event","Hand-Generated","Self-Propelled")
postTTest(D,"looking_time","exp","Experiment 5","test_event","Hand-Generated","Self-Propelled")
setwd("C:/Users/bentod2/Documents/projects/current/spelkeSaxeSimulationsNEW/postMS/final/JEPGeneral/revision2/simulations/spelkePhillipsWoodward1995/SRN/3Contact3NoContactTestEvents/Data")
object.salient = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
object.nonsalient = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
people.salient = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
people.nonsalient = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
# combine dataframes into a single 'D' data frame
D = rbind(people.salient, people.nonsalient, object.salient, object.nonsalient)
# get dimensionality of D
dim(D)
# create an ID column
D$ID = rep(1:80, each = 40)
# create trial type column
D$trialType = rep(c("Contact", "No Contact"), each = 1,  times = 1600)
D$trialType = as.factor(D$trialType)
# create condition column
D$condition = rep(c("People", "Objects"),
each = 1600)
D$condition = as.factor(D$condition)
# create frequency column
D$train.type = rep(c("Salient", "Nonsalient","Salient", "Nonsalient"),
each = 800, times = 1)
D$train.type = as.factor(D$train.type)
# create a 'looking time' column
D$lookingTime = D$V3
# remove columns and get the names of the resulting columns
D = D[,-c(1:3)]
names(D)
####################
## OMNIBUS FIGURE ##
####################
# figure
condition_barplot = ggplot(D, aes(condition, lookingTime, fill=trialType)) # create the bar graph with test.trial.2 on the x-axis and measure on the y-axis
###############################################################
###############################################################
##                                                           ##
## MAIN ANALYSES FOR THE SIMULATIONS OF SPELKE ET AL. (1995) ##
##                                                           ##
###############################################################
###############################################################
# SIMULATION 1 ANALYSIS #
# load libraries
library(lme4)
library(nlme)
library(boot)
library(car)
library(reshape2)
library(ggplot2)
library(ez)
library(plyr)
library(ggsignif)
library(lsr)
library(sjmisc)
library(sjstats)
library(BayesFactor)
library(foreign)
library(dplyr)
library(lattice)
library(openxlsx)
library(Hmisc)
# figure
condition_barplot = ggplot(D, aes(condition, lookingTime, fill=trialType)) # create the bar graph with test.trial.2 on the x-axis and measure on the y-axis
condition_barplot + stat_summary(fun = mean, geom = "bar", position = "dodge") + # add the bars, which represent the means and the place them side-by-side with 'dodge'
stat_summary(fun.data=mean_cl_boot, geom = "errorbar", position = position_dodge(width=0.90), width = 0.2) + # add errors bars
ylab("Looking Time") + # change the label of the y-axis
facet_wrap(~train.type, ncol=2) +
scale_y_continuous(expand = c(0, 0)) +
coord_cartesian(ylim=c(0, 300)) +
scale_fill_manual(values = c("black", "azure3")) +
labs(fill='Test Trial')  +
theme(axis.text.x = element_text(size = 10),
axis.text.y = element_text(size = 10),
legend.text=element_text(size=10),
legend.title = element_text(size=10),
axis.title=element_text(size=10),
strip.text = element_text(
size = 10),
axis.title.x = element_blank())
object.salient = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
object.nonsalient = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
people.salient = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
people.nonsalient = read.table(file.choose(), header = FALSE, stringsAsFactors = FALSE)
# combine dataframes into a single 'D' data frame
D = rbind(people.salient, people.nonsalient, object.salient, object.nonsalient)
# get dimensionality of D
dim(D)
# create an ID column
D$ID = rep(1:80, each = 40)
# create trial type column
D$trialType = rep(c("Contact", "No Contact"), each = 1,  times = 1600)
D$trialType = as.factor(D$trialType)
# create condition column
D$condition = rep(c("People", "Objects"),
each = 1600)
D$condition = as.factor(D$condition)
# create frequency column
D$train.type = rep(c("Salient", "Nonsalient","Salient", "Nonsalient"),
each = 800, times = 1)
D$train.type = as.factor(D$train.type)
# create a 'looking time' column
D$lookingTime = D$V3
# remove columns and get the names of the resulting columns
D = D[,-c(1:3)]
names(D)
####################
## OMNIBUS FIGURE ##
####################
# figure
condition_barplot = ggplot(D, aes(condition, lookingTime, fill=trialType)) # create the bar graph with test.trial.2 on the x-axis and measure on the y-axis
condition_barplot + stat_summary(fun = mean, geom = "bar", position = "dodge") + # add the bars, which represent the means and the place them side-by-side with 'dodge'
stat_summary(fun.data=mean_cl_boot, geom = "errorbar", position = position_dodge(width=0.90), width = 0.2) + # add errors bars
ylab("Looking Time") + # change the label of the y-axis
facet_wrap(~train.type, ncol=2) +
scale_y_continuous(expand = c(0, 0)) +
coord_cartesian(ylim=c(0, 300)) +
scale_fill_manual(values = c("black", "azure3")) +
labs(fill='Test Trial')  +
theme(axis.text.x = element_text(size = 10),
axis.text.y = element_text(size = 10),
legend.text=element_text(size=10),
legend.title = element_text(size=10),
axis.title=element_text(size=10),
strip.text = element_text(
size = 10),
axis.title.x = element_blank())
